"use client";
import {
  require_react
} from "./chunk-SFSNRMVL.js";
import {
  __toESM
} from "./chunk-LXPOGQIV.js";

// node_modules/react-native-safe-area-context/lib/module/SafeAreaContext.js
var React2 = __toESM(require_react());
import { Dimensions, StyleSheet } from "react-native";

// node_modules/react-native-safe-area-context/lib/module/NativeSafeAreaProvider.web.js
var React = __toESM(require_react());
import { View } from "react-native";
var CSSTransitions = {
  WebkitTransition: "webkitTransitionEnd",
  Transition: "transitionEnd",
  MozTransition: "transitionend",
  MSTransition: "msTransitionEnd",
  OTransition: "oTransitionEnd"
};
function NativeSafeAreaProvider({
  children,
  style,
  onInsetsChange
}) {
  React.useEffect(() => {
    if (typeof document === "undefined") {
      return;
    }
    const element = createContextElement();
    document.body.appendChild(element);
    const onEnd = () => {
      const {
        paddingTop,
        paddingBottom,
        paddingLeft,
        paddingRight
      } = window.getComputedStyle(element);
      const insets = {
        top: paddingTop ? parseInt(paddingTop, 10) : 0,
        bottom: paddingBottom ? parseInt(paddingBottom, 10) : 0,
        left: paddingLeft ? parseInt(paddingLeft, 10) : 0,
        right: paddingRight ? parseInt(paddingRight, 10) : 0
      };
      const frame = {
        x: 0,
        y: 0,
        width: document.documentElement.offsetWidth,
        height: document.documentElement.offsetHeight
      };
      onInsetsChange({
        nativeEvent: {
          insets,
          frame
        }
      });
    };
    element.addEventListener(getSupportedTransitionEvent(), onEnd);
    onEnd();
    return () => {
      document.body.removeChild(element);
      element.removeEventListener(getSupportedTransitionEvent(), onEnd);
    };
  }, [onInsetsChange]);
  return React.createElement(View, {
    style
  }, children);
}
var _supportedTransitionEvent = null;
function getSupportedTransitionEvent() {
  if (_supportedTransitionEvent != null) {
    return _supportedTransitionEvent;
  }
  const element = document.createElement("invalidtype");
  _supportedTransitionEvent = CSSTransitions.Transition;
  for (const key in CSSTransitions) {
    if (element.style[key] !== void 0) {
      _supportedTransitionEvent = CSSTransitions[key];
      break;
    }
  }
  return _supportedTransitionEvent;
}
var _supportedEnv = null;
function getSupportedEnv() {
  if (_supportedEnv !== null) {
    return _supportedEnv;
  }
  const {
    CSS
  } = window;
  if (CSS && CSS.supports && CSS.supports("top: constant(safe-area-inset-top)")) {
    _supportedEnv = "constant";
  } else {
    _supportedEnv = "env";
  }
  return _supportedEnv;
}
function getInset(side) {
  return `${getSupportedEnv()}(safe-area-inset-${side})`;
}
function createContextElement() {
  const element = document.createElement("div");
  const {
    style
  } = element;
  style.position = "fixed";
  style.left = "0";
  style.top = "0";
  style.width = "0";
  style.height = "0";
  style.zIndex = "-1";
  style.overflow = "hidden";
  style.visibility = "hidden";
  style.transitionDuration = "0.05s";
  style.transitionProperty = "padding";
  style.transitionDelay = "0s";
  style.paddingTop = getInset("top");
  style.paddingBottom = getInset("bottom");
  style.paddingLeft = getInset("left");
  style.paddingRight = getInset("right");
  return element;
}

// node_modules/react-native-safe-area-context/lib/module/SafeAreaContext.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var isDev = true;
var SafeAreaInsetsContext = React2.createContext(null);
if (isDev) {
  SafeAreaInsetsContext.displayName = "SafeAreaInsetsContext";
}
var SafeAreaFrameContext = React2.createContext(null);
if (isDev) {
  SafeAreaFrameContext.displayName = "SafeAreaFrameContext";
}
function SafeAreaProvider({
  children,
  initialMetrics,
  initialSafeAreaInsets,
  style,
  ...others
}) {
  const parentInsets = useParentSafeAreaInsets();
  const parentFrame = useParentSafeAreaFrame();
  const [insets, setInsets] = React2.useState((initialMetrics == null ? void 0 : initialMetrics.insets) ?? initialSafeAreaInsets ?? parentInsets ?? null);
  const [frame, setFrame] = React2.useState((initialMetrics == null ? void 0 : initialMetrics.frame) ?? parentFrame ?? {
    // Backwards compat so we render anyway if we don't have frame.
    x: 0,
    y: 0,
    width: Dimensions.get("window").width,
    height: Dimensions.get("window").height
  });
  const onInsetsChange = React2.useCallback((event) => {
    const {
      nativeEvent: {
        frame: nextFrame,
        insets: nextInsets
      }
    } = event;
    setFrame((curFrame) => {
      if (
        // Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== curFrame.height || nextFrame.width !== curFrame.width || nextFrame.x !== curFrame.x || nextFrame.y !== curFrame.y)
      ) {
        return nextFrame;
      } else {
        return curFrame;
      }
    });
    setInsets((curInsets) => {
      if (!curInsets || nextInsets.bottom !== curInsets.bottom || nextInsets.left !== curInsets.left || nextInsets.right !== curInsets.right || nextInsets.top !== curInsets.top) {
        return nextInsets;
      } else {
        return curInsets;
      }
    });
  }, []);
  return React2.createElement(NativeSafeAreaProvider, _extends({
    style: [styles.fill, style],
    onInsetsChange
  }, others), insets != null ? React2.createElement(SafeAreaFrameContext.Provider, {
    value: frame
  }, React2.createElement(SafeAreaInsetsContext.Provider, {
    value: insets
  }, children)) : null);
}
var styles = StyleSheet.create({
  fill: {
    flex: 1
  }
});
function useParentSafeAreaInsets() {
  return React2.useContext(SafeAreaInsetsContext);
}
function useParentSafeAreaFrame() {
  return React2.useContext(SafeAreaFrameContext);
}
var NO_INSETS_ERROR = "No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.";
function useSafeAreaInsets() {
  const insets = React2.useContext(SafeAreaInsetsContext);
  if (insets == null) {
    throw new Error(NO_INSETS_ERROR);
  }
  return insets;
}
function useSafeAreaFrame() {
  const frame = React2.useContext(SafeAreaFrameContext);
  if (frame == null) {
    throw new Error(NO_INSETS_ERROR);
  }
  return frame;
}
function withSafeAreaInsets(WrappedComponent) {
  return React2.forwardRef((props, ref) => {
    const insets = useSafeAreaInsets();
    return React2.createElement(WrappedComponent, _extends({}, props, {
      insets,
      ref
    }));
  });
}
function useSafeArea() {
  return useSafeAreaInsets();
}
var SafeAreaConsumer = SafeAreaInsetsContext.Consumer;
var SafeAreaContext = SafeAreaInsetsContext;

// node_modules/react-native-safe-area-context/lib/module/SafeAreaView.web.js
var React3 = __toESM(require_react());
import { StyleSheet as StyleSheet2, View as View2 } from "react-native";
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}
var defaultEdges = {
  top: "additive",
  left: "additive",
  bottom: "additive",
  right: "additive"
};
function getEdgeValue(inset, current, mode) {
  switch (mode) {
    case "off":
      return current;
    case "maximum":
      return Math.max(current, inset);
    case "additive":
    default:
      return current + inset;
  }
}
var SafeAreaView = React3.forwardRef(({
  style = {},
  mode,
  edges,
  ...rest
}, ref) => {
  const insets = useSafeAreaInsets();
  const edgesRecord = React3.useMemo(() => {
    if (edges == null) {
      return defaultEdges;
    }
    return Array.isArray(edges) ? edges.reduce((acc, edge) => {
      acc[edge] = "additive";
      return acc;
    }, {}) : (
      // ts has trouble with refining readonly arrays.
      edges
    );
  }, [edges]);
  const appliedStyle = React3.useMemo(() => {
    const flatStyle = StyleSheet2.flatten(style);
    if (mode === "margin") {
      const {
        margin = 0,
        marginVertical = margin,
        marginHorizontal = margin,
        marginTop = marginVertical,
        marginRight = marginHorizontal,
        marginBottom = marginVertical,
        marginLeft = marginHorizontal
      } = flatStyle;
      const marginStyle = {
        marginTop: getEdgeValue(insets.top, marginTop, edgesRecord.top),
        marginRight: getEdgeValue(insets.right, marginRight, edgesRecord.right),
        marginBottom: getEdgeValue(insets.bottom, marginBottom, edgesRecord.bottom),
        marginLeft: getEdgeValue(insets.left, marginLeft, edgesRecord.left)
      };
      return [style, marginStyle];
    } else {
      const {
        padding = 0,
        paddingVertical = padding,
        paddingHorizontal = padding,
        paddingTop = paddingVertical,
        paddingRight = paddingHorizontal,
        paddingBottom = paddingVertical,
        paddingLeft = paddingHorizontal
      } = flatStyle;
      const paddingStyle = {
        paddingTop: getEdgeValue(insets.top, paddingTop, edgesRecord.top),
        paddingRight: getEdgeValue(insets.right, paddingRight, edgesRecord.right),
        paddingBottom: getEdgeValue(insets.bottom, paddingBottom, edgesRecord.bottom),
        paddingLeft: getEdgeValue(insets.left, paddingLeft, edgesRecord.left)
      };
      return [style, paddingStyle];
    }
  }, [edgesRecord.bottom, edgesRecord.left, edgesRecord.right, edgesRecord.top, insets.bottom, insets.left, insets.right, insets.top, mode, style]);
  return React3.createElement(View2, _extends2({
    style: appliedStyle
  }, rest, {
    ref
  }));
});

// node_modules/react-native-safe-area-context/lib/module/InitialWindow.js
var initialWindowMetrics = null;
var initialWindowSafeAreaInsets = null;
export {
  SafeAreaConsumer,
  SafeAreaContext,
  SafeAreaFrameContext,
  SafeAreaInsetsContext,
  SafeAreaProvider,
  SafeAreaView,
  initialWindowMetrics,
  initialWindowSafeAreaInsets,
  useSafeArea,
  useSafeAreaFrame,
  useSafeAreaInsets,
  withSafeAreaInsets
};
//# sourceMappingURL=react-native-safe-area-context.js.map
